knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(jsonlite)
library(geojsonio)
library(lubridate)
library(sf)
library(janitor)
GPS <- read_delim("/Documentos//Datos Para OD/GPS/2019-06-13.csv",
";", escape_double = FALSE, col_names = FALSE,
trim_ws = TRUE)
columnas<-read_delim("/Documentos/Datos Para OD/GPS/gps_header.csv",
";", escape_double = FALSE, col_names = TRUE,
trim_ws = TRUE)
columnas<-clean_names(columnas)
a<-colnames(columnas)
colnames(GPS)<-a
GPS<- st_as_sf(GPS, coords = c("longitude", "latitude"), crs = 4326)
vias<- read_sf("/Google Drive/00 Trabajo/MOP/DPIT/shapes/Vial/Propuesta Primaria/PRIMARIA_TRAMOS_BUSES_/PRIMARIA_TRAMOS_BUSES_.shp")
vias_sep<-mutate(vias, BUS=paste(BUS_NAC,",",BUS_PROV,",",BUS_MUN)) %>%
separate_rows(BUS, sep = ",") %>%
mutate(BUS=as.numeric(BUS)) %>%
filter(!is.na(BUS)) %>%
as.data.frame() %>%
select(BUS, IDTRAMO)
st_crs(vias)
vias<-st_transform(vias,5348)
buffer<-filter(vias,red_RMBA=="primaria") %>%
st_buffer(25) %>%
st_transform(4326)
#nos quedamos solamente con los puntos que estan dentro del buffer creado
gps_principales<-st_intersection(GPS,buffer)
#filtramos y nos quedamos solo con las columnas que nos sirven, o creemos que nos puedan servir
gps_principales<-select(gps_principales, codigoentidad, idlinea, interno, c_ld_id, dtsn, date_time, type, direction, status, IDTRAMO)
#hacemos que la columna date time este parseada como fecha
gps_principales<-mutate(gps_principales, date_time==date(date_time))
primeros<-function(A, t=20){
select(A, date_time, interno,idlinea, IDTRAMO) %>%    #selecciona las columnas que vamos a usar
mutate (date_time=dmy_hms(date_time)) %>%             #parsea la fecha de manera correcta
arrange( interno, date_time) %>%                      #ordena por numero de interno y por fecha
group_by(idlinea, interno, IDTRAMO) %>%               #agrupa por linea, interno y tramo
mutate(agrupado=(date_time-lag(date_time))/dminutes(1)) %>% #saca la diferencia de tiempo con el registro anterior y lo pone en minutos
mutate(agrupado = if_else(is.na(agrupado),1,if_else(agrupado>t,1,0))) %>%  #si no hay registro anterior o la diferencia es mayor a t (20 min) asigna a la columna agrupado un 1 sino deja un 0
filter(agrupado==1) #nos quedamos con los registros con agrupado =1
}
gps_primeros<-primeros(gps_principales) %>%  #aplicamos la funcion "primeros"
mutate(hora=hour(date_time)) #incorporamos una columna que es la hora
REL<-read_delim("~/Datos Para OD/Otros/Relacion_Empresa-Linea.csv",
";", escape_double = FALSE, trim_ws = TRUE) #leemos el diccionario que vincula id_linea con numero de linea
REL<-mutate(REL,LINEA=parse_number(REL$LINEA)) %>%  # nos quedamos solamente con la parte numÃ©rica del campo linea
filter(!is.na(LINEA)) %>% #nos quedamos con los registros que no son nulos
select(ID_LINEA,LINEA)# nos quedamos con los campos que creemos utiles
gps_primeros<-left_join(gps_primeros,REL, by=c("idlinea"="ID_LINEA")) # a todos los puntos gps le incorporamos el numero de linea correspondiente con un left join.
gps_primeros_union<-left_join(gps_primeros,vias_sep, by = c('IDTRAMO', "BUS"="LINEA")) # Aca lo complicado unimos todos los puntos gps de un tramo con las posibles lineas del tramo, luego comparamos el campo BUS del tramos con el campo Linea del gps, si son el mismo me lo quedo. Estoy pensando que se puede hacer un left join con multiples keys, voy a probar eso.
gps_primeros_union<-left_join(gps_primeros,vias_sep, by = c('IDTRAMO', "LINEA"="BUS")) # Aca lo complicado unimos todos los puntos gps de un tramo con las posibles lineas del tramo, luego comparamos el campo BUS del tramos con el campo Linea del gps, si son el mismo me lo quedo. Estoy pensando que se puede hacer un left join con multiples keys, voy a probar eso.
gps_primeros_union<-left_join(gps_primeros,vias_sep, by = c('IDTRAMO')) # Aca lo complicado unimos todos los puntos gps de un tramo con las posibles lineas del tramo, luego comparamos el campo BUS del tramos con el campo Linea del gps, si son el mismo me lo quedo. Estoy pensando que se puede hacer un left join con multiples keys, voy a probar eso.
gps_primeros_union<-filter(gps_primeros_union, BUS==LINEA)
vias_serv<-left_join(vias,servicios_dia)
servicios_hora<-as.data.frame(gps_primeros_union) %>%
group_by(IDTRAMO,hora) %>%
summarise(ser_hora=n())
servicios_dia<-as.data.frame(gps_primeros_union) %>%
group_by(IDTRAMO) %>%
summarise(ser_dia=n())
vias_serv<-left_join(vias,servicios_dia)
View(vias_serv)
write_sf(vias_serv,"/Google Drive/00 Trabajo/MOP/DPIT/shapes/Vial/Propuesta Primaria/PRIMARIA_TRAMOS_BUSES_/primaria_tramos_servicios.geojson")
library(tidyverse)
library(jsonlite)
library(sf)
ruta<-"D:/Documentos/api_transporte/datos/2021-06-24"
lista<-list.files(ruta)
DF <-  read_sf(sprintf("%s/%s",ruta,lista[1]))
for (f in lista[-1]){
df <- read_sf(sprintf("%s/%s",ruta,f))      # read the file
DF <- rbind(DF, df)    # append the current file
}
why?
max(DF$fecha)
library(lubridate)
View(DF)
df<-mutate(DF, fecha=ymd_hms(fecha))
max(df$fecha)
lista[-1]
lista[-1]
max(df$fecha)
b<-sprintf("%s/%s_0.geojson",ruta,str_sub(ruta,-10,-1))
write_sf(DF,b)
lista<-list.files(ruta)
DF <-  read_sf(sprintf("%s/%s",ruta,lista[1]))
for (f in lista[-1]){
df <- read_sf(sprintf("%s/%s",ruta,f))      # read the file
DF <- rbind(DF, df)    # append the current file
}
DF <-  read_sf(sprintf("%s/%s",ruta,lista[1]))
DF <-  read_sf(sprintf("%s/%s",ruta,lista[2]))
